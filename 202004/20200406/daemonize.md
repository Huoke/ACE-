# Lighttpd进程守护化
顺着main函数执行流程，第一个值得我们仔细分析的是函数daemonize()调用，该函数将使得Lighttpd执行进程转换为守护进程。
进程守护化使得Lighttpd脱离控制终端而在后台执行提供服务，避免了Lighttpd在执行过程中的信息在任何终端上显示，同时也使得Lighttpd进程不会被任何终端信息所打断。
进程守护化使得Lighttpd应用程序不能随便被其他操作或进程干扰，也不随便干扰其他操作或进程,在一般情况下，这正是我们所需要的。
当然，我们也可以不将Lighttpd进程守护化，这很简单，只要在执行Lighttpd时加上选项D即可。

创建一个守护进程有一些固定的步骤，下面我们就来看Lighttpd进程守护化的执行步骤，如清单2-1所示。

清单2-1　Lighttpd进程守护化
```c
//server.c
1.#ifdef HAVE_FORK
2./*network is up,let's deamonize ourself*/
/*这里是根据设置判断是否要调用函数daemonize()进行守护化。*/
3.if(srv-＞srvconf.dont_daemonize==0)daemonize();
4.#endif
5.#ifdef HAVE_FORK
/*完成Lighttpd进程守护化执行步骤的实现函数。*/
6.static void daemonize(void){
/*下面几行用于屏蔽一些有关控制终端操作的信号，防止在守护进程没有正常运转起来前控制终端受到干扰退出或挂起。*/
7.#ifdef SIGTTOU
8.signal(SIGTTOU,SIG_IGN);//表示忽略后台进程写控制终端信号。
9.#endif
10.#ifdef SIGTTIN
11.signal(SIGTTIN,SIG_IGN);//表示忽略后台进程读控制终端信号。
12.#endif
13.#ifdef SIGTSTP
14.signal(SIGTSTP,SIG_IGN);//表示忽略终端挂起。
15.#endif
/*到这为止，当前进程（指Lighttpd进程，下同）还只是普通进程，下面就要逐一采用各个步骤，使得当前进程逐步具备守护进程的各个特性，完成从普通进程到守护进程的转变。
目标一：后台运行。由于守护进程最终将脱离控制终端，运行于后台，因此需要采用一定的方法使得普通进程脱离控制终端，这个方法就是首先在普通进程中调用fork函数后，使父进程终止，让子进程继续执行，此时由于父进程先于子进程结束，使得子进程成为孤儿进程，因此自动被1号进程（init）收养。因为子进程是原父进程的完全复制，而子进程又将在后台执行，完成预期目标，这也就是的“脱壳”。*/
16.if(0!=fork())exit(0);
/*目标二：脱离控制终端、登录会话和进程组。如果要普通进程脱离控制终端、登录会话和进程组，不受它们的影响，一般使用setsid()设置新会话的首进程，则与原来的登录会话和进程组自动脱离。
我们知道进程属于一个进程组（进程组是一个或多个进程的集合），进程组ID（GID）就是该进程组组长进程的进程ID（PID），因此我们也就可以通过GID来识别组长进程。组长进程的存在与否并不关系到进程组的存在与否，也就是说，只要进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。
登录会话（Session）是包含一个或多个进程组的集合，这些进程组共享一个控制终端，而这个控制终端通常是创建第一个进程的登录终端，控制终端、登录会话和进程组通常是从父进程继承下来的。会话、进程组、进程与控制终端之间的关系如表2-1所示。
```
