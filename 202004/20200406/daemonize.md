# Lighttpd进程守护化
顺着main函数执行流程，第一个值得我们仔细分析的是函数daemonize()调用，该函数将使得Lighttpd执行进程转换为守护进程。
进程守护化使得Lighttpd脱离控制终端而在后台执行提供服务，避免了Lighttpd在执行过程中的信息在任何终端上显示，同时也使得Lighttpd进程不会被任何终端信息所打断。
进程守护化使得Lighttpd应用程序不能随便被其他操作或进程干扰，也不随便干扰其他操作或进程,在一般情况下，这正是我们所需要的。
当然，我们也可以不将Lighttpd进程守护化，这很简单，只要在执行Lighttpd时加上选项D即可。

创建一个守护进程有一些固定的步骤，下面我们就来看Lighttpd进程守护化的执行步骤，如清单2-1所示。

清单2-1　Lighttpd进程守护化
```c
//server.c
1.#ifdef HAVE_FORK
2./*network is up,let's deamonize ourself*/
/*这里是根据设置判断是否要调用函数daemonize()进行守护化。*/
3.if(srv-＞srvconf.dont_daemonize==0)daemonize();
4.#endif
5.#ifdef HAVE_FORK
/*完成Lighttpd进程守护化执行步骤的实现函数。*/
6.static void daemonize(void){
/*下面几行用于屏蔽一些有关控制终端操作的信号，防止在守护进程没有正常运转起来前控制终端受到干扰退出或挂起。*/
7.#ifdef SIGTTOU
8.signal(SIGTTOU,SIG_IGN);//表示忽略后台进程写控制终端信号。
9.#endif
10.#ifdef SIGTTIN
11.signal(SIGTTIN,SIG_IGN);//表示忽略后台进程读控制终端信号。
12.#endif
13.#ifdef SIGTSTP
14.signal(SIGTSTP,SIG_IGN);//表示忽略终端挂起。
15.#endif
/*到这为止，当前进程（指Lighttpd进程，下同）还只是普通进程，下面就要逐一采用各个步骤，使得当前进程逐步具备守护进程的各个特性，完成从普通进程到守护进程的转变。
目标一：后台运行。由于守护进程最终将脱离控制终端，运行于后台，因此需要采用一定的方法使得普通进程脱离控制终端，这个方法就是首先在普通进程中调用fork函数后，使父进程终止，让子进程继续执行，此时由于父进程先于子进程结束，使得子进程成为孤儿进程，因此自动被1号进程（init）收养。因为子进程是原父进程的完全复制，而子进程又将在后台执行，完成预期目标，这也就是的“脱壳”。*/
16.if(0!=fork())exit(0);
/*目标二：脱离控制终端、登录会话和进程组。如果要普通进程脱离控制终端、登录会话和进程组，不受它们的影响，一般使用setsid()设置新会话的首进程，则与原来的登录会话和进程组自动脱离。
我们知道进程属于一个进程组（进程组是一个或多个进程的集合），进程组ID（GID）就是该进程组组长进程的进程ID（PID），因此我们也就可以通过GID来识别组长进程。组长进程的存在与否并不关系到进程组的存在与否，也就是说，只要进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。
登录会话（Session）是包含一个或多个进程组的集合，这些进程组共享一个控制终端，而这个控制终端通常是创建第一个进程的登录终端，控制终端、登录会话和进程组通常是从父进程继承下来的。会话、进程组、进程与控制终端之间的关系如表2-1所示。
完成我们第二个目标的步骤就是让当前进程调用setsid()，调用成功后，进程就成为新的会话首进程（Session Leader）和新的进程组组长（新进程组ID为当前进程ID），并与原来的登录会话和进程组脱离，同时进程与原来的（如果存在）控制终端联系被脱离。*/
17.if(-1==setsid())exit(0);
/*根据前面叙述，能正常执行到此处的应该是子进程（父进程已经终止了），并且该子进程也已经脱离控制终端、原来的登录会话和进程组，似乎已经完成了从普通进程到守护进程的转换。事实上也是如此，简单的守护进程转换的确已经完成了，但是我们知道目前的该子进程是一个会话的首进程和进程组的组长进程，对于某些系统（如SVR4），当会话首进程打开一个尚未与任何会话相关联的终端设备时，此设备自动作为控制终端分配给该会话，这与守护进程不关联控制终端的特性不符合。因此，我们要采用不再让该子进程成为会话首进程的方式来禁止进程重新打开关联控制终端，方法就是再次调用fork函数，该fork函数执行后，子进程结束，孙子进程也不再是会话首进程，避免了会话再次关联到控制主终端。
当会话首进程退出的时候可能向其所在会话的所有进程（当然就包括孙子进程）发送SIGHUP信号，而SIGHUP信号的默认处理函数是结束进程。为了防止孙子进程意外结束，因此需要忽略SIGHUP信号（孙子进程也继承了这一点），直到子进程退出，孙子进程被启动进程(init)收养。*/＜/p＞
18.signal(SIGHUP,SIG_IGN);
/*fork孙子进程，退出子进程。*/
19.if(0!=fork())exit(0);
/*最后目标：改变工作目录到根目录。进程活动时，其工作目录所在的文件系统不能卸下，一般需要将工作目录改变到根目录，注意用户对此目录需要有读写权，防止超级用户卸载设备时系统报告设备忙。*/
20.if(0!=chdir("/"))exit(0);
/*执行到此，基本就完成了从普通进程到守护进程的所有特性转变，至于还有其他的常规工作，如关闭文件描述符，并重定向标准输入、输出和错误输出以及设置守护进程的文件权限创建掩码等，有的在此前就已经完成26或者针对Lighttpd本身就不需要那么做。*/
21.}
22.#endif
```
表2-1 fork函数
| 主题 | 内容 |
|---- | ----|
|表头文件 | #include<sys/types.h> #include <unistd.h> |
| 定义函数 | pid_t fork(void) |
| 函数说明 |  |


表2-2 setsid函数

| 主题 | 内容 |
|---- | ----|
|表头文件 | #include<sys/types.h> #include <unistd.h> |
| 定义函数 | pid_t setsid(void) |
| 函数说明 | 如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话，结果为：1）此进程变成新会话组的会话组长(session leader,会话组首进程是创建该会话组的进程)。此进程是该新会话组中的唯一进程。2）此进程称为一个新进程组的组长进程。新进程组ID是此调用进程的进程ID. 3) 此进程没有控制终端。如果在调用setsid之前此进程有一个控制终端，那么这种联系也被解除了。 |
| 返回值 | 执行成功返回会话ID(也就是进行该调用的进程ID)，出错则返回1|
|附加说明 | 如果此调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不是一个进程组的组长|


表2-3 signal、sigaction函数
|主题 |内容 |
|---- | ----|
|表头文件 | #include <signal.h> |
|函数定义 | typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler);int sigaction(signum, const struct sigaction *act, struct sigaction* oldact);|
|函数说明 |signal()会依参数signum指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行 。如果参数handler不是函数指针，则必须是下列两个常数之一：- SIG_IGN，忽略参数signum指定的信号。- SIG_DFL，将参数signum指定的信号重设为核心预设的信号处理方式。sigaction() 用于修改与指定信号相关联的处理函数，参数signum可以是SIGKILL和SIGSTOP之外的任何有效信号。| 
|返回值 | 执行成功函数signal则返回先前的信号处理函数指针，否则返回SIG_ERR(-1)。执行成功函数sigaction则返回0，否则-1|
|附加说明 | 在信号发送跳转到自定的handler处理函数执行后，系统会自动将此处理函数换回原来系统预设的处理方式，也就是说signal函数每次设置具体的信号处理函数(非SIG_IGN)只能生效一次，每次在进程响应处理信号后，随即将信号处理函数恢复为默认处理方式。所以如果向多次以相同方式处理某个信号，通常的做法是，在响应函数开始，再次调用signal进行设置。但是这样会存在问题，那就是在信号发送之后到信号处理程序中调用signal函数之间有一个时间窗口。在此段时间中，可能发送另一次中断信号。第二个信号会造成执行默认动作，而对中断信号则是终止该进程。这种类型的程序段在大多数情况下回正常工作，使得我们认为它们正确，而实际上却并不是如此。因此，对于需要多次生效的信号处理设置，应该采用另外一个函数sigaction。相比signal函数而言， sigaction函数设置的信号处理有如下特点：- 在信号处理程序被调用时，系统建立的信号屏蔽字会自动包括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止，即不会丢失信号。- 响应函数设置后就一直有效，不会重置，因此可以多次生效。- 对除SIGALRM以外的所有信号都企图设置SA_RESTART标志，于是被这些信号中断的系统调用(read,write)都能自动再启动。不希望再启动由SIGALRM信号中断的系统调用的原因是希望对I/O操作可以设置时间限制。也就是说当信号到来中断其阻塞的I/O操作或其他阻塞的操作时，他们会自动启动这些操作，而不会中断这些操作。而这些I/O操作会保持原来的阻塞状态就好像根本没有信号到来一样 |

表2-4 chdir函数
| 主题 | 内容 |
|---- | ----|
| 表头文件 | #include<unistd.h> |
| 函数定义 | int chdir(const char* path) |
| 函数说明 | 用来将当前的工作目录改变成以参数path所指的目录 |
| 返回值 | 执行成功则返回0，失败则返回-1，errno为错误代码 |
| 附加说明 | fork后的子进程继承父进程的当前工作目录 |  
守护进程
守护进程（Daemon），也称为精灵进程，是一种运行在后台的特殊进程，它独立于控制终端，并周期性地执行某项任务或等待处理某些发生的事件。像Lighttpd这种服务器进程以及许多系统任务进程，比如打印进程Lpd，一般都要做成守护进程。
从定义可以看出，守护进程有三个最基本的特点：后台运行，独立于终端，完成一定的任务。所谓的后台运行是指守护进程一般没有图形界面或终端不可见的；而独立于终端是说守护进程不和终端交互，守护进程运行之后一般不接受终端的输入也不向终端输出；而完成一定的任务是指每一个守护进程都是为了完成一定的服务任务或管理任务而存在的，这些任务一般都是与系统管理服务相关的任务。
除了上面提到的这些特殊性以外，守护进程与普通进程基本上没有什么区别。因此，守护进程可以由一个普通进程按照上述的守护进程的特性而改造而来。

![](http://tiebapic.baidu.com/forum/w%3D580%3B/sign=b801f6e0deea15ce41eee001863b3bf3/3801213fb80e7becefdd9b84382eb9389b506b54.jpg)

Lighttpd进程守护转换完整过程如图2-2所示，完成守护转换的Lighttpd进程脱离控制终端，此时如果要关闭Lighttpd应用程序，用Ctrl+C已经不起作用，不过可以使用命令"kill-9 10652 10653 10654 10655 10656"（10652 10653 10654 10655 10656为Lighttpd进程ID，包括一个监控进程和四个工作进程）或使用命令"killall lighttpd"等。

![](http://tiebapic.baidu.com/forum/w%3D580/sign=920e99ce143b5bb5bed720f606d2d523/f901c87b02087bf4b0ebcf8ce5d3572c10dfcfe2.jpg)


